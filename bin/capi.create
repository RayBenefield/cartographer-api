#!/usr/local/bin/bash

# This gets the path of the executing script.
SELF_PATH=$(cd -P -- "$(dirname -- "${0}")" && pwd -P) && SELF_PATH=${SELF_PATH}/$(basename -- "${0}")
# If the path is a symlink (which is likely if it is in /usr/local/bin) this will get the actual filepath.
REAL_FILE=$(readlink ${SELF_PATH})
# If it isn't a symlink then let's stick with SELF_PATH
if [[ -z $REAL_FILE ]]; then
    REAL_FILE=${SELF_PATH}
fi
REAL_DIR=$(dirname ${REAL_FILE})

source $REAL_DIR/colors.sh
source $REAL_DIR/functions.sh

echo

# Provide help.
getopts h help
if [[ "${help}" = "h" ]]; then
    PrintInfo "Description"
    echo
    PrintDescription "This script installs the ${BIBlue}CAPI${No_Color} architecture on AWS."
    echo
    PrintInfo "Usage"
    echo
    PrintCodeLine "capi.create [-h]"
    echo
    PrintInfo "Examples"
    echo
    PrintCodeLine "script.template"
    echo
    PrintBoldInfo "Required Environment Variables"
    echo
    PrintCodeLine "${BICyan}EXAMPLE_ENV_VARIABLE${Cyan}=<some-description-of-variable>"
    echo

    exit
fi

DomainStacks=( Games MapGames )

for Stack in "${DomainStacks[@]}"
do
	StackId=$(aws cloudformation create-stack --stack-name Capi-${Stack} --template-body file:////Users//GodlyPerfection//CAPI-Workspace//${Stack}//Template.json --capabilities CAPABILITY_IAM --query StackId)
	PrintInfo "Creating the ${BIBlue}${Stack}${Green} stack with ID ${BIBlue}${StackId}${No_Color}..."
done

echo

spin='/-\|'
n=${#spin}
PrintSeparator
printf '    Â» Waiting...  '
while true
do
	Statuses=$(aws cloudformation describe-stacks --query Stacks[*].StackStatus --output text)

	if [[ ! ${Statuses[*]} =~ "CREATE_IN_PROGRESS" ]]; then
		break
	fi
	printf "%s\b" "${spin:i++%n:1}"
	sleep .01;
done

PrintBoldInfo "DONE!"
PrintSeparator
echo

declare -A OutputMap
for Stack in "${DomainStacks[@]}"
do
	Outputs=$(aws cloudformation describe-stacks --stack-name Capi-${Stack} --query 'Stacks[0].Outputs[*].[OutputKey,OutputValue]' --output text)
	while IFS=$'\t' read -r -a Output
	do
		OutputMap[${Output[0]}]=${Output[1]}
	done <<< "${Outputs[@]}"
done


PrintInfo "Mapping Queues to Topics..."
echo
Indent

# GamesForMapGames Queue -sub-> to Games-New Topic
# QueueGames:TopicNewMapGames
# GamesForGameEvents Queue -sub-> to Games-New Topic
# QueueGames:TopicNewGameEvents
# GamesForPlayers Queue -sub-> to Games-New Topic
# Games:New-Players
# PlayersForPlayerGameCounts Queue -sub-> to Players-New Topic
# Players:New-PlayerGameCounts
# PlayerGamesForGames Queue -sub-> to PlayerGames-New Topic
# PlayerGames-New-Games
# PlayerGameCountsForPlayerGames Queue -sub-> to PlayerGameCounts-New/Updated/Continue Topics
# PlayerGames:New-PlayerGameCounts
# PlayerGames:Updated-PlayerGameCounts
# PlayerGames:Continue-PlayerGameCounts

Mappings=( "QueueMapGames:TopicNewGames" )
for Mapping in "${Mappings[@]}"
do
	# Split mapping into ${TargetDomain} `:` ${SourceTopic}
	IFS=':' read -ra Map <<< "$Mapping"
	QueueKey=${Map[0]}
	TopicKey=${Map[1]}

	# Get Queue/Topic ARN from Outputs with "Queue${TargetDomain}" key
	QueueArn=${OutputMap[${QueueKey}]}
	TopicArn=${OutputMap[${TopicKey}]}

	PrintInfo "${BIBlue}${TopicArn}${Green} ----> ${BIBlue}${QueueArn}${No_Color}"

	# Subscribe Queue to Topic
done




Unindent
echo
PrintSeparator
PrintBoldInfo "Finished creating CAPI!"
echo
